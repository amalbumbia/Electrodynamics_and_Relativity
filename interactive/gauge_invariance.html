<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../assets/header-css.css">
  <link rel="stylesheet" href="../assets/mainStyle.css">
<title>Gauge Invariance</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: #fff;
    color: #111;
  }

  header {
    padding: 12px 16px;
    border-bottom: 1px solid #ddd;
  }

  h1 {
    margin: 0;
    font-size: 16px;
  }

  /* Layout: controls + plots */
  .wrap {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 12px;
    padding: 12px;
    box-sizing: border-box;
  }

  /* Panels */
  .panel {
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #fff;
    display: flex;
    flex-direction: column;
  }

  .panel h2 {
    margin: 0;
    padding: 8px 10px;
    border-bottom: 1px solid #eee;
    font-size: 14px;
  }

  .panel .body {
    padding: 10px;
  }

  label {
    display: block;
    font-size: 12px;
    margin: 6px 0 4px;
  }

  .row {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }

  input[type=range] {
    width: 100%;
  }

  input, select, button {
    font-size: 12px;
  }

  button.btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background: #f5f5f5;
    border-radius: 6px;
    cursor: pointer;
  }

  button.btn[aria-pressed="true"] {
    background: #e0e0e0;
  }

  /* Plots grid: multiple panels side by side */
  .plots-grid {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }

  .plot-card {
    padding: 10px;
  }

  canvas {
    width: 100%;
    height: 220px;
    display: block;
  }

  .legend {
    display: flex;
    gap: 12px;
    align-items: center;
    font-size: 12px;
    color: #444;
    flex-wrap: wrap;
  }

  .legend span.dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
  }

  #E0, #kVal {
    width: 72px;
  }

  /* Responsive: stack controls on top on narrow screens */
  @media (max-width: 800px) {
    .wrap {
      grid-template-columns: 1fr;
    }

    canvas {
      height: 200px;
    }
  }
</style>
</head>
<body>
  <header>
    <h1>Gauge Invariance</h1>
  </header>

  <main class="wrap">
    <!-- Controls -->
    <section class="panel">
      <h2>Controls</h2>
      <div class="body">
        <label>Time
          <input id="tRange" type="range" min="0" max="6.28318530718" step="0.001" value="0" />
        </label>
        <div class="row">
          <button id="playBtn" class="btn" aria-pressed="false">Play</button>
          <label>Speed
            <input id="speed" type="number" min="0.1" step="0.1" value="1.0" />
          </label>
        </div>
        <div class="row">
          <label>E₀
            <input id="E0" type="number" step="0.1" value="1.0" />
          </label>
          <label>k
            <input id="kVal" type="number" step="0.1" value="1.0" />
          </label>
        </div>
      </div>
    </section>

    <!-- Plots: all cases visible at once -->
    <section class="plots-grid">
      <!-- Coulomb gauge potentials -->
      <div class="panel">
        <h2>Potentials — Coulomb Gauge</h2>
        <div class="plot-card">
          <canvas id="potCoulombCanvas" width="1000" height="240"></canvas>
          <div class="legend">
            <span class="dot" style="background:#c0392b;"></span><span>Aᵧ</span>
            <span class="dot" style="background:#bbb;"></span><span>V = 0, Aₓ = 0 (not shown)</span>
          </div>
        </div>
      </div>

      <!-- Lorenz gauge potentials -->
      <div class="panel">
        <h2>Potentials — Lorenz Gauge</h2>
        <div class="plot-card">
          <canvas id="potLorenzCanvas" width="1000" height="240"></canvas>
          <div class="legend">
            <span class="dot" style="background:#c0392b;"></span><span>V</span>
            <span class="dot" style="background:#1f77b4;"></span><span>Aₓ</span>
            <span class="dot" style="background:#2ca02c;"></span><span>Aᵧ</span>
          </div>
        </div>
      </div>

      <!-- Fields (gauge invariant) -->
      <div class="panel">
        <h2>Fields (Gauge Invariant)</h2>
        <div class="plot-card">
          <canvas id="fldCanvas" width="1000" height="240"></canvas>
          <div class="legend">
            <span class="dot" style="background:#1f77b4;"></span><span>Eᵧ</span>
            <span class="dot" style="background:#2ca02c;"></span><span>B_z</span>
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  const COLORS = {
    grid: '#eee',
    zero: '#ccc',
    axis: '#666',
    potV: '#c0392b',
    potAx: '#1f77b4',
    potAy: '#2ca02c',
    Ey: '#1f77b4',
    Bz: '#2ca02c'
  };

  const c = 1.0;            // c=1 units
  const TWO_PI = Math.PI * 2;

  const state = {
    t: 0,
    E0: 1.0,
    k: 1.0,
    get w() { return c * this.k; },
    get alpha() { return this.E0 / (this.w * this.k); },
    playing: false,
    last: performance.now(),
    speed: 1.0
  };

  // DOM elements
  const tRange = document.getElementById('tRange');
  const playBtn = document.getElementById('playBtn');
  const speedEl = document.getElementById('speed');
  const E0El = document.getElementById('E0');
  const kEl = document.getElementById('kVal');

  const potCoulombCanvas = document.getElementById('potCoulombCanvas');
  const potLorenzCanvas = document.getElementById('potLorenzCanvas');
  const fldCanvas = document.getElementById('fldCanvas');

  const pCoulCtx = potCoulombCanvas.getContext('2d');
  const pLorenCtx = potLorenzCanvas.getContext('2d');
  const fCtx = fldCanvas.getContext('2d');

  // Spatial grid
  const N = 700;
  const xMin = -2 * Math.PI;
  const xMax =  2 * Math.PI;
  const xs = new Float64Array(N);
  for (let i = 0; i < N; i++) {
    xs[i] = xMin + (xMax - xMin) * i / (N - 1);
  }

  function theta(x, t) {
    return state.k * x - state.w * t;
  }

  // Potentials in given gauge
  function potentials(gauge, t) {
    const V  = new Float64Array(N);
    const Ax = new Float64Array(N);
    const Ay = new Float64Array(N);

    for (let i = 0; i < N; i++) {
      const th = theta(xs[i], t);
      if (gauge === 'coulomb') {
        V[i]  = 0;
        Ax[i] = 0;
        Ay[i] = (state.E0 / state.w) * Math.sin(th);
      } else { // Lorenz
        V[i]  = - state.alpha * state.w * Math.sin(th);
        Ax[i] = - state.alpha * state.k * Math.sin(th);
        Ay[i] = (state.E0 / state.w) * Math.sin(th);
      }
    }
    return { V, Ax, Ay };
  }

  // Fields (gauge invariant)
  function fields(t) {
    const Ey = new Float64Array(N);
    const Bz = new Float64Array(N);

    for (let i = 0; i < N; i++) {
      const th = theta(xs[i], t);
      Ey[i] = state.E0 * Math.cos(th);
      Bz[i] = (state.E0 / c) * Math.cos(th);
    }
    return { Ey, Bz };
  }

  // Drawing helpers
  function clear(ctx) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  }

  function mapX(x, W) {
    return 40 + (x - xMin) * (W - 60) / (xMax - xMin);
  }

  function mapY(y, yMin, yMax, H) {
    return 10 + (yMax - y) * (H - 40) / (yMax - yMin);
  }

  function maxAbs(arr) {
    let m = 0;
    for (let i = 0; i < arr.length; i++) {
      const a = Math.abs(arr[i]);
      if (a > m) m = a;
    }
    return m;
  }

  function drawAxes(ctx, yMin, yMax) {
    const W = ctx.canvas.width;
    const H = ctx.canvas.height;

    ctx.save();

    // Grid
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let gx = 0; gx <= 10; gx++) {
      const x = 40 + (W - 60) * gx / 10;
      ctx.moveTo(x, 10);
      ctx.lineTo(x, H - 30);
    }
    for (let gy = 0; gy <= 6; gy++) {
      const y = 10 + (H - 40) * gy / 6;
      ctx.moveTo(40, y);
      ctx.lineTo(W - 20, y);
    }
    ctx.stroke();

    // Zero line
    const y0 = mapY(0, yMin, yMax, H);
    ctx.strokeStyle = COLORS.zero;
    ctx.beginPath();
    ctx.moveTo(40, y0);
    ctx.lineTo(W - 20, y0);
    ctx.stroke();

    ctx.restore();
  }

  function drawLine(ctx, ys, color, yMin, yMax) {
    const W = ctx.canvas.width;
    const H = ctx.canvas.height;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const X = mapX(xs[i], W);
      const Y = mapY(ys[i], yMin, yMax, H);
      if (i === 0) ctx.moveTo(X, Y);
      else ctx.lineTo(X, Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Render functions
  function renderPotentialsCoulomb() {
    clear(pCoulCtx);
    const { Ay } = potentials('coulomb', state.t);
    const amp = Math.max(1e-6, maxAbs(Ay)) || 1;
    const yMax = Math.max(1, amp * 1.2);
    const yMin = -yMax;

    drawAxes(pCoulCtx, yMin, yMax);
    drawLine(pCoulCtx, Ay, COLORS.potAy, yMin, yMax);
  }

  function renderPotentialsLorenz() {
    clear(pLorenCtx);
    const { V, Ax, Ay } = potentials('lorenz', state.t);
    const amp = Math.max(maxAbs(V), maxAbs(Ax), maxAbs(Ay), 1);
    const yMax = Math.max(1, amp * 1.2);
    const yMin = -yMax;

    drawAxes(pLorenCtx, yMin, yMax);
    drawLine(pLorenCtx, V,  COLORS.potV,  yMin, yMax);
    drawLine(pLorenCtx, Ax, COLORS.potAx, yMin, yMax);
    drawLine(pLorenCtx, Ay, COLORS.potAy, yMin, yMax);
  }

  function renderFields() {
    clear(fCtx);
    const { Ey, Bz } = fields(state.t);
    const amp = Math.max(maxAbs(Ey), maxAbs(Bz), 1);
    const yMax = Math.max(1, amp * 1.2);
    const yMin = -yMax;

    drawAxes(fCtx, yMin, yMax);
    drawLine(fCtx, Ey, COLORS.Ey, yMin, yMax);
    drawLine(fCtx, Bz, COLORS.Bz, yMin, yMax);
  }

  function renderAll() {
    renderPotentialsCoulomb();
    renderPotentialsLorenz();
    renderFields();
  }

  // Event wiring
  tRange.addEventListener('input', e => {
    state.t = parseFloat(e.target.value);
    renderAll();
  });

  playBtn.addEventListener('click', () => {
    state.playing = !state.playing;
    playBtn.setAttribute('aria-pressed', state.playing);
    playBtn.textContent = state.playing ? 'Pause' : 'Play';
    state.last = performance.now();
    if (state.playing) requestAnimationFrame(tick);
  });

  speedEl.addEventListener('change', e => {
    const v = parseFloat(e.target.value);
    state.speed = (isNaN(v) || v <= 0) ? 1.0 : v;
    speedEl.value = state.speed.toString();
  });

  E0El.addEventListener('change', e => {
    const v = parseFloat(e.target.value);
    state.E0 = isNaN(v) ? 1.0 : v;
    E0El.value = state.E0.toString();
    renderAll();
  });

  kEl.addEventListener('change', e => {
    const v = parseFloat(e.target.value);
    state.k = (isNaN(v) || v <= 0) ? 1.0 : v;
    kEl.value = state.k.toString();
    renderAll();
  });

  function tick(now) {
    if (!state.playing) return;
    const dt = (now - state.last) / 1000;
    state.last = now;
    state.t = (state.t + dt * state.speed) % TWO_PI;
    tRange.value = state.t;
    renderAll();
    requestAnimationFrame(tick);
  }

  // Initial draw
  renderAll();
})();
</script>
<script src="../header-loader.js"></script>
</body>
</html>
